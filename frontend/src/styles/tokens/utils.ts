/**
 * Утилиты для работы с темами и дизайн-токенами
 * 
 * Содержит функции для переключения тем, работы с CSS переменными
 * и другие полезные утилиты для работы с токенами.
 */

import { tokens } from './index';\nimport type { \n  ThemeMode, \n  ThemeConfig, \n  CSSVariableMap, \n  SpacingKey, \n  FontSizeKey, \n  ShadowKey,\n  BorderRadiusKey\n} from './types';\n\n// ============================================================================\n// THEME UTILITIES - Утилиты для работы с темами\n// ============================================================================\n\n/**\n * Получает текущую тему из localStorage или системных настроек\n */\nexport function getCurrentTheme(): ThemeMode {\n  if (typeof window === 'undefined') return 'light';\n  \n  const stored = localStorage.getItem('theme') as ThemeMode | null;\n  if (stored && ['light', 'dark', 'auto'].includes(stored)) {\n    return stored;\n  }\n  \n  return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';\n}\n\n/**\n * Применяет тему к документу\n */\nexport function applyTheme(mode: ThemeMode): void {\n  if (typeof window === 'undefined') return;\n  \n  const root = document.documentElement;\n  const body = document.body;\n  \n  // Удаляем существующие классы тем\n  root.classList.remove('light', 'dark');\n  body.classList.remove('light', 'dark');\n  \n  if (mode === 'auto') {\n    const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;\n    const effectiveMode = systemPrefersDark ? 'dark' : 'light';\n    root.classList.add(effectiveMode);\n    body.classList.add(effectiveMode);\n  } else {\n    root.classList.add(mode);\n    body.classList.add(mode);\n  }\n  \n  // Сохраняем в localStorage\n  localStorage.setItem('theme', mode);\n}\n\n/**\n * Переключает тему\n */\nexport function toggleTheme(): ThemeMode {\n  const current = getCurrentTheme();\n  const next: ThemeMode = current === 'light' ? 'dark' : 'light';\n  applyTheme(next);\n  return next;\n}\n\n/**\n * Устанавливает высококонтрастную тему\n */\nexport function setHighContrast(enabled: boolean): void {\n  if (typeof window === 'undefined') return;\n  \n  const root = document.documentElement;\n  \n  if (enabled) {\n    root.classList.add('high-contrast');\n    root.setAttribute('data-theme', 'high-contrast');\n  } else {\n    root.classList.remove('high-contrast');\n    root.removeAttribute('data-theme');\n  }\n  \n  localStorage.setItem('high-contrast', enabled.toString());\n}\n\n/**\n * Устанавливает режим уменьшенной анимации\n */\nexport function setReducedMotion(enabled: boolean): void {\n  if (typeof window === 'undefined') return;\n  \n  const root = document.documentElement;\n  \n  if (enabled) {\n    root.classList.add('reduce-motion');\n  } else {\n    root.classList.remove('reduce-motion');\n  }\n  \n  localStorage.setItem('reduced-motion', enabled.toString());\n}\n\n/**\n * Получает полную конфигурацию темы\n */\nexport function getThemeConfig(): ThemeConfig {\n  return {\n    mode: getCurrentTheme(),\n    highContrast: localStorage.getItem('high-contrast') === 'true',\n    reducedMotion: localStorage.getItem('reduced-motion') === 'true',\n  };\n}\n\n/**\n * Применяет полную конфигурацию темы\n */\nexport function applyThemeConfig(config: ThemeConfig): void {\n  applyTheme(config.mode);\n  setHighContrast(config.highContrast);\n  setReducedMotion(config.reducedMotion);\n}\n\n// ============================================================================\n// CSS VARIABLE UTILITIES - Утилиты для работы с CSS переменными\n// ============================================================================\n\n/**\n * Получает значение CSS переменной\n */\nexport function getCSSVariable(name: keyof CSSVariableMap): string {\n  if (typeof window === 'undefined') return '';\n  \n  return getComputedStyle(document.documentElement)\n    .getPropertyValue(name)\n    .trim();\n}\n\n/**\n * Устанавливает значение CSS переменной\n */\nexport function setCSSVariable(name: keyof CSSVariableMap, value: string): void {\n  if (typeof window === 'undefined') return;\n  \n  document.documentElement.style.setProperty(name, value);\n}\n\n/**\n * Устанавливает несколько CSS переменных\n */\nexport function setCSSVariables(variables: Partial<CSSVariableMap>): void {\n  if (typeof window === 'undefined') return;\n  \n  const root = document.documentElement;\n  \n  Object.entries(variables).forEach(([name, value]) => {\n    if (value !== undefined) {\n      root.style.setProperty(name, value);\n    }\n  });\n}\n\n/**\n * Удаляет CSS переменную\n */\nexport function removeCSSVariable(name: keyof CSSVariableMap): void {\n  if (typeof window === 'undefined') return;\n  \n  document.documentElement.style.removeProperty(name);\n}\n\n// ============================================================================\n// TOKEN UTILITIES - Утилиты для работы с токенами\n// ============================================================================\n\n/**\n * Получает значение токена по пути\n */\nexport function getTokenValue(path: string): any {\n  return path.split('.').reduce((obj, key) => obj?.[key], tokens);\n}\n\n/**\n * Создает CSS переменную из токена\n */\nexport function createCSSVariable(name: string, value: any): string {\n  return `--${name}: ${value};`;\n}\n\n/**\n * Конвертирует все токены в CSS переменные\n */\nexport function tokensToCSS(): string {\n  const cssVariables: string[] = [];\n  \n  // Цвета\n  Object.entries(tokens.colors.brand).forEach(([key, value]) => {\n    cssVariables.push(createCSSVariable(`color-brand-${key}`, value));\n  });\n  \n  Object.entries(tokens.colors.neutral).forEach(([key, value]) => {\n    cssVariables.push(createCSSVariable(`color-neutral-${key}`, value));\n  });\n  \n  Object.entries(tokens.colors.semantic).forEach(([category, colors]) => {\n    Object.entries(colors).forEach(([key, value]) => {\n      cssVariables.push(createCSSVariable(`color-${category}-${key}`, value));\n    });\n  });\n  \n  // Интервалы\n  Object.entries(tokens.spacing).forEach(([key, value]) => {\n    cssVariables.push(createCSSVariable(`spacing-${key.replace('.', '-')}`, value));\n  });\n  \n  // Типографика\n  Object.entries(tokens.typography.fontSize).forEach(([key, [size, { lineHeight }]]) => {\n    cssVariables.push(createCSSVariable(`font-size-${key}`, size));\n    cssVariables.push(createCSSVariable(`line-height-${key}`, lineHeight));\n  });\n  \n  // Тени\n  Object.entries(tokens.shadows).forEach(([key, value]) => {\n    cssVariables.push(createCSSVariable(`shadow-${key}`, value));\n  });\n  \n  // Радиусы\n  Object.entries(tokens.borderRadius).forEach(([key, value]) => {\n    cssVariables.push(createCSSVariable(`border-radius-${key}`, value));\n  });\n  \n  return `:root {\\n  ${cssVariables.join('\\n  ')}\\n}`;\n}\n\n// ============================================================================\n// RESPONSIVE UTILITIES - Утилиты для адаптивности\n// ============================================================================\n\n/**\n * Проверяет, соответствует ли текущий экран заданному breakpoint\n */\nexport function matchesBreakpoint(breakpoint: keyof typeof tokens.breakpoints): boolean {\n  if (typeof window === 'undefined') return false;\n  \n  const breakpointValue = tokens.breakpoints[breakpoint];\n  return window.matchMedia(`(min-width: ${breakpointValue})`).matches;\n}\n\n/**\n * Создает медиа-запрос для breakpoint\n */\nexport function createMediaQuery(breakpoint: keyof typeof tokens.breakpoints): string {\n  return `@media (min-width: ${tokens.breakpoints[breakpoint]})`;\n}\n\n/**\n * Получает текущий breakpoint\n */\nexport function getCurrentBreakpoint(): keyof typeof tokens.breakpoints | null {\n  if (typeof window === 'undefined') return null;\n  \n  const breakpoints = Object.entries(tokens.breakpoints)\n    .sort(([, a], [, b]) => parseInt(a) - parseInt(b))\n    .reverse();\n  \n  for (const [name, value] of breakpoints) {\n    if (window.matchMedia(`(min-width: ${value})`).matches) {\n      return name as keyof typeof tokens.breakpoints;\n    }\n  }\n  \n  return null;\n}\n\n// ============================================================================\n// SPACING UTILITIES - Утилиты для работы с интервалами\n// ============================================================================\n\n/**\n * Конвертирует значение интервала в пиксели\n */\nexport function spacingToPx(spacing: SpacingKey): number {\n  const value = tokens.spacing[spacing];\n  \n  if (value === '0') return 0;\n  if (value === '1px') return 1;\n  \n  // Конвертируем rem в px (предполагаем, что 1rem = 16px)\n  return parseFloat(value) * 16;\n}\n\n/**\n * Создает объект стилей для интервалов\n */\nexport function createSpacingStyles(spacing: SpacingKey): Record<string, string> {\n  const value = tokens.spacing[spacing];\n  \n  return {\n    margin: value,\n    padding: value,\n    gap: value,\n  };\n}\n\n// ============================================================================\n// ANIMATION UTILITIES - Утилиты для анимации\n// ============================================================================\n\n/**\n * Создает CSS для анимации\n */\nexport function createAnimationCSS(name: string, duration: string, easing: string): string {\n  return `animation: ${name} ${duration} ${easing};`;\n}\n\n/**\n * Создает переход с токенами\n */\nexport function createTransition(property: string = 'all', duration: keyof typeof tokens.animation.duration = '200', easing: keyof typeof tokens.animation.easing = 'inOut'): string {\n  return `transition: ${property} ${tokens.animation.duration[duration]} ${tokens.animation.easing[easing]};`;\n}\n\n/**\n * Проверяет, предпочитает ли пользователь уменьшенную анимацию\n */\nexport function prefersReducedMotion(): boolean {\n  if (typeof window === 'undefined') return false;\n  \n  return window.matchMedia('(prefers-reduced-motion: reduce)').matches;\n}\n\n// ============================================================================\n// COLOR UTILITIES - Утилиты для работы с цветами\n// ============================================================================\n\n/**\n * Получает цвет по семантическому значению\n */\nexport function getSemanticColor(semantic: 'success' | 'warning' | 'error' | 'info', shade: keyof typeof tokens.colors.semantic.success = '500'): string {\n  return tokens.colors.semantic[semantic][shade];\n}\n\n/**\n * Получает цвет бренда\n */\nexport function getBrandColor(shade: keyof typeof tokens.colors.brand = '500'): string {\n  return tokens.colors.brand[shade];\n}\n\n/**\n * Получает нейтральный цвет\n */\nexport function getNeutralColor(shade: keyof typeof tokens.colors.neutral = '500'): string {\n  return tokens.colors.neutral[shade];\n}\n\n/**\n * Конвертирует HEX в RGB\n */\nexport function hexToRgb(hex: string): { r: number; g: number; b: number } | null {\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n  return result ? {\n    r: parseInt(result[1], 16),\n    g: parseInt(result[2], 16),\n    b: parseInt(result[3], 16)\n  } : null;\n}\n\n/**\n * Создает цвет с прозрачностью\n */\nexport function withOpacity(color: string, opacity: number): string {\n  const rgb = hexToRgb(color);\n  if (!rgb) return color;\n  \n  return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;\n}\n\n// ============================================================================\n// VALIDATION UTILITIES - Утилиты для валидации\n// ============================================================================\n\n/**\n * Проверяет, является ли значение валидным токеном интервала\n */\nexport function isValidSpacingToken(value: string): value is SpacingKey {\n  return Object.keys(tokens.spacing).includes(value);\n}\n\n/**\n * Проверяет, является ли значение валидным токеном размера шрифта\n */\nexport function isValidFontSizeToken(value: string): value is FontSizeKey {\n  return Object.keys(tokens.typography.fontSize).includes(value);\n}\n\n/**\n * Проверяет, является ли значение валидным токеном тени\n */\nexport function isValidShadowToken(value: string): value is ShadowKey {\n  return Object.keys(tokens.shadows).includes(value);\n}\n\n/**\n * Проверяет, является ли значение валидным токеном радиуса\n */\nexport function isValidBorderRadiusToken(value: string): value is BorderRadiusKey {\n  return Object.keys(tokens.borderRadius).includes(value);\n}\n\n// ============================================================================\n// PERFORMANCE UTILITIES - Утилиты для производительности\n// ============================================================================\n\n/**\n * Создает debounced функцию для обработки изменений темы\n */\nexport function debounce<T extends (...args: any[]) => void>(func: T, delay: number): T {\n  let timeoutId: NodeJS.Timeout;\n  \n  return ((...args: Parameters<T>) => {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => func(...args), delay);\n  }) as T;\n}\n\n/**\n * Создает throttled функцию для обработки событий\n */\nexport function throttle<T extends (...args: any[]) => void>(func: T, limit: number): T {\n  let inThrottle: boolean;\n  \n  return ((...args: Parameters<T>) => {\n    if (!inThrottle) {\n      func(...args);\n      inThrottle = true;\n      setTimeout(() => inThrottle = false, limit);\n    }\n  }) as T;\n}\n\n// ============================================================================\n// INITIALIZATION - Инициализация\n// ============================================================================\n\n/**\n * Инициализирует систему токенов\n */\nexport function initializeTokens(): void {\n  if (typeof window === 'undefined') return;\n  \n  // Применяем сохраненную тему\n  const savedTheme = getCurrentTheme();\n  applyTheme(savedTheme);\n  \n  // Применяем сохраненные настройки\n  const highContrast = localStorage.getItem('high-contrast') === 'true';\n  const reducedMotion = localStorage.getItem('reduced-motion') === 'true';\n  \n  if (highContrast) setHighContrast(true);\n  if (reducedMotion) setReducedMotion(true);\n  \n  // Слушаем изменения системной темы\n  const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');\n  const handleSystemThemeChange = (e: MediaQueryListEvent) => {\n    const currentTheme = getCurrentTheme();\n    if (currentTheme === 'auto') {\n      applyTheme('auto');\n    }\n  };\n  \n  if (mediaQuery.addEventListener) {\n    mediaQuery.addEventListener('change', handleSystemThemeChange);\n  } else {\n    // Fallback для старых браузеров\n    mediaQuery.addListener(handleSystemThemeChange);\n  }\n  \n  // Слушаем изменения предпочтений анимации\n  const motionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n  const handleMotionChange = (e: MediaQueryListEvent) => {\n    setReducedMotion(e.matches);\n  };\n  \n  if (motionQuery.addEventListener) {\n    motionQuery.addEventListener('change', handleMotionChange);\n  } else {\n    motionQuery.addListener(handleMotionChange);\n  }\n}\n\n// ============================================================================\n// EXPORT DEFAULT UTILITIES - Экспорт основных утилит\n// ============================================================================\n\nexport const themeUtils = {\n  getCurrentTheme,\n  applyTheme,\n  toggleTheme,\n  setHighContrast,\n  setReducedMotion,\n  getThemeConfig,\n  applyThemeConfig,\n};\n\nexport const tokenUtils = {\n  getTokenValue,\n  createCSSVariable,\n  tokensToCSS,\n  getCSSVariable,\n  setCSSVariable,\n  setCSSVariables,\n  removeCSSVariable,\n};\n\nexport const colorUtils = {\n  getSemanticColor,\n  getBrandColor,\n  getNeutralColor,\n  hexToRgb,\n  withOpacity,\n};\n\nexport const spacingUtils = {\n  spacingToPx,\n  createSpacingStyles,\n};\n\nexport const animationUtils = {\n  createAnimationCSS,\n  createTransition,\n  prefersReducedMotion,\n};\n\nexport const responsiveUtils = {\n  matchesBreakpoint,\n  createMediaQuery,\n  getCurrentBreakpoint,\n};\n\nexport const validationUtils = {\n  isValidSpacingToken,\n  isValidFontSizeToken,\n  isValidShadowToken,\n  isValidBorderRadiusToken,\n};\n\nexport const performanceUtils = {\n  debounce,\n  throttle,\n};
